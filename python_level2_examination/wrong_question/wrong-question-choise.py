# -*- coding: utf-8 -*-
# 链表存储空间不一定连续，且各元素的存储顺序是任意的，数组是连续存储的，所以数组可以通过下标访问，链表不可以。

# 循环队列是队列的一种顺序储存结构，用队尾指针rear指向队列中的队尾元素，排头指针front指向排头元素的前一个位置。排头指针front指向的后一个位置
# 直到队尾指针rear指向的位置之间所有元素都是队列中的元素，对头指针可大于队尾也可以小于队尾

#  字符串可以保存在变量中，也可以单独存在（注释是单独存在的字符串） 字符串是一个字符序列，字符串中的编号叫“索引”

# Python的分支结构 已经执行过的除非是在循环里，或者递归里，是不会重复执行的

# Python通过解释器内置的open()函数打开一个文件（用文本方式打开时，我们读取的是字符串，用二进制方式打开时，我们是按照字节流）
# Python能够以文本和二进制两种方式处理文件
# 文件使用结束后要用close0方法关闭，释放文件的使用授权

# 用于Python数据分析的第三方库有：numpy ，pandas ，scipy

# divmod 取模  返回x // t 和 x % t的结果  是一个元祖

# 1. 数据库有模式、内模式、外模式，其中内模式和模式只能有一个，可以有多个外模式，指的是视图
# 外模式就是面向用户的，内模式是面向系统的。概念模式是包括内和外模式

# 2. 零件和实体是互不关联的2个东西，零件可以属于多个实体，实体也可以有多种零件，所以是多对多的关系
# 4. Python不是系统语言，python是解释型脚本适合网络，web开发，数值计算和动画 系统语言是c语言，
# 5. 循环也可以遍历字典，字典就属于非序列元素，也可以遍历二叉树
# 8. Python中read是读取前i个字符，i不传读所有，readall()读所有
# 9. Writelins是将一个数组使用逗号分割，拼接成一个字符串

# 程序化结构是基本结构有：顺序结构、选择（分支）结构和重复（循环）结构。

# 进程是程序的执行过程

# 有一个列表为ls，min(ls) 返回列表ls的最小值，max(ls)返回最大值，使用这俩元素前提是列表内的各元素是可以比较的，否则会报错 list(X)将x转换为列表类型
# ls.remove(x)，删除列表ls中出现的第一个元素，ls.copy()生成一个新列表，复制ls的所有元素，
# ls.append()在ls最后增加一个元素。ls。reverse()反转列表ls中的所有元素

# 字典是中的键值对之间没有顺序且不能重复，通过字典实现映射，键必须唯一
# python中字典的key不能是可变类型。字典可存储任意类型对象,其中值可以取任何数据类型,但键必须是不可变的,如字符串、数字或元组。（不能是list）
# 序列是python中最基本的数据结构，是一维元素向量（str，tuple和list都属于序列类型）--- 字典类型用于表示二维数据
# 组合数据类型可以分为：序列类型（字符串和列表），集合类型，映射类型（包括：元组，列表，集合，字典，映射）

# C是静态语言 是系统编程语言，python是脚本解释语言，与C/C++和Java有很大区别，没有主函数的说法
# 编译是将源代码逐条转换成目标代码的过程，解释是将源代码逐条转换成目标代码同时逐条云讯目标代码的过程。
# python语言在3种基本控制逻辑（顺序结构、选择结构（分支结构）、循环结构）上进行了适当的扩展
# 在分支结构原理的基础，python增加了异常处理，使用try-except保留字

# print(0x452//2)
# A = 16*16*4+5*16+2
# print(6%7)

# 程序设计还是强调可读性，指令花费的时间就叫指令周期
# 算法和规模有关系，空间和数据的存储结构有关系
# 顺序程序肯定没有并发性，并发会导致执行的先后顺序不一致
# 数组可以是一维的，也可以是二维的，也可以是三维度数组,n层也可以。
# writelines是空格分割的字符串，csv需要逗号分隔的字符串
# 序列元素是指数组，字符串，元祖，可以通过下标，只有一维的线性数据结构


# 数据结构指相互有关联的数据元素的集合
# 满二叉树的节点个数等于  2的深度次方，减去1 叶子节点数等于2的（深度-1）次方
# 继承，多态属于面向对象程序设计。
# 结构化：自上而下，模块化，逐步求精
# 信息隐蔽性最直接相关的概念是模块独立性，也就是封装
# 关系表就是select语句查出来的很多行记录，每一行是一个元祖，有个题（e,e,6,1）   属性是字段  码类似于索引有多个属性构成
# print(eval("Hello")) 会报错 name 'Hello' is not defined  eval函数的定义为：eval(source,globals:=None,locals=None,)
# continue不能跳出循环 是继续循环
# time库中ctime()函数能够将一个表示时间的 浮点数变成人类可以理解的时间格式
#
# sys.version查看 python的版本
# import time
#
# start_time = time.perf_counter()
# 这个time.sleep()让程序执行到这里停顿x秒，再执行后面的 函数
# time.sleep(3)
# perf_counter返回的是当前是多少秒
# end_time = time.perf_counter()
# print("程序执行时间 {}".format(end_time - start_time))
# 同心圆
import turtle as t

# def DrawCctCircle(n):
#     t.penup()
#     t.goto(0,-n)
#     t.pendown()
#     t.circle(n)
# for i in range(20,80,20):
#     DrawCctCircle(i)
# t.done()


# 软件工程三要素：过程，方法，工具
# 软件设置原则包括：模型抽象，信息隐蔽，逐步求精，模块化，自顶向下
# 结构化程序设计方法的主要原则为：自顶向下、逐步求精、模块化和限制使用goto语句
# 结构化设计，就是每个模块每个模块之间的调用
# 面向对象的基本概念：面向对象方法涵盖对象及对象属性与方法、类、继承、多态性几个基本要素。
# 关系数据库中，表示实体之间联系的是-二维表
# 栈和队列都是线性结构

# 程序和数据互相解耦，不影响，不是单独存放
#
# +表示的是5.67*10的8次方法
# print(1.23e-4+5.67e+8j.real) ==》1.23e-4 +  56700000000j.real

# d = {}
# for i in range(26):
#     d[chr(i+ord("a"))] = chr((i+13) % 26 + ord("a"))
# for c in "Python":
#     print(d.get(c, c), end="")

22
# 我们知道'a'的ascii是97 , 'A'的ascii是65

# 现在要循环Python
# 根据字母顺序知道P是80,上面的循环是计算小写字母的，所以P不变2
# 根据字母顺序我们知道y是121, y要等于121
# 根据 d[chr(i + ord("a"))]这里的i要是24,才是计算y的加密
# i等于24的情况下，(i + 13) % 26 等于21, 所以y是a偏移21位的加密结果，是v


# Java c属于静态语言，需要先编译成.class文件，再执行.class文件   Python属于脚本语言 脚本语言编译的是代码  （解释脚本，静态编译）
# python语言：随时命名、随时赋值、随时使用 需要指定释放或程序结束才能释放 不能随时变化类型

# 计算机的CPU通过总线与内存、外设等连接
# 允许多个联机用户同事使用一台计算机系统进行计算的操作系统称为分时操作系统
# turtle的home()是画笔回到原点，朝向东
# pip工具的常用命令有安装（install）,(download),(show),(serch)
# -V属于pyinstaller 命令的常用参数， -F是指在dist文件夹中只生成独立的打包文件（exe文件）所有第三方依赖、资源和代码均打包进此exe中

# # 需要输出'90','89','93'
# ls = ['90','89','93']
# l = ''
# for i in ls:
#     # 拼接成了字符串
#     # l = ','.join(ls)
#     # 写入的是'90','89','93'，可知分别是字符串，且逗号分隔
#     l += "'{}'".format(i) + ','
# print(l)

# open()文件只是被打开，不会装入内存，只有执行读取操作的时候，才会将文件放入内存
# ls = []
# for i in 'Nation':
#     for k in range(2):
#         if i == 'n':
#             break
#         ls.append(i)
#         print(i, end='')
#         print(ls)

# 自己定义的函数可以与内置函数同名，调用的时候会优先调用自己定义的函数，
# 集合中使用add()方法增加新元素，不能使用中括号，字典的items()返回所有的键值对
# DFD结构化方法的需求分析工具

# 在PFD图中用箭头表示 控制流
# 数据库设计分为四个阶段：
# 1)需求分析阶段：编写软件规格说明书及初步的用户手册，提交评审。
# 2)概念设计（概要设计)阶段：E-R图设计阶段。
# 3)逻辑设计阶段：主要是ER转换成关系模式。
# 4)物理设计阶段。
# 数据库设计是数据库应用的核心
# 数据库设计的基本任务是根据用户对象的信息需求、处理需求和数据库的支持 环境设计出数据模式
# 数据库设计可以采用生命周期法
# 数据库的三级模式结构指数据库系统有外模式、模式和内模式3级构成。
# 数据库管理系统在这3级模式之间提供了两层映射：外模式/模式映射，模式/内模式映射。

# 参数是组合类型（可变对象）时，改变原参数的值
# 参数是list类型时，改变原参数的值
# 参数是int类型时，不改变原参数的值

# 不止数组，字符串，都是按位比较大小的 字符串比较对应的ascii 字母小写大于大写 a是97 A是65


# 操作系统提供了进程管理、设备管理、文件管理和储存器管理

# # Python包含的保留字可以执行如下命令进行查看：
# import keyword
# print(keyword.kwlist)
# ['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert',
# 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except',
# 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or',
# 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

# pip install Pylnstaller
# (cmd命令行)pyinstaller-F<文件名.py>  用Pyinstaller工具把Python源文件打包成一个独立的可执行文件

# str1='python'
# print(str1.center(10, '*'))

# import random
#
# ls = [2, 3, 4, 6]
# s = 10
# k = random.randint(0, 2)
# s += ls[k]
# print(s)


# 为了解决CPU和主存之间的速度匹配问题，应该在主存储器和CPU之间增加高速缓冲存储器Cache.
# 多道程序设计技术是指允许多个程序同时进入内存并运行
# 1nf不可再分，2nf部分传递依赖，3nf完全传递依赖

# 带符号的定点数，正数的原码，反码、补码均相同；
# 负数的反码是对该数的原码除符号外个位取反，补码是在该数的反码的最后（即最右边）一位上加1，
# 不管是正数还是负数，其补码的符号位取反即是偏移码
# 元组是不可变且有顺序的组合数据类型
# s = 2
# n = 0
# while s <= 10:
#     s = s + 2
#     n = n + 1
# print(n)

# 正数之间采用除法运算的时候结果是浮点数，除了除法外数字类型在进行运算都会是两者之间最高等级的数据类型，复数>浮点数>正数

# eval（）函数的参数必须是字符串类型
# 组合数据类型根据数据的关系分为序列类型，集合类型和映射类型，其中序列类型又包含字符串，元组和列表，
# 集合类型和映射类型都是没有顺序的数据类型，不能通过序号访问
# def a():
#     a,b = 1000,99
#     for i in range(10):
#         a *= b+1
#         b *= a-1
#     return a<b
# print(a())

# # 复数的加减运算与数学中相同，但是注意虚部为0的时候，j不能省略
# a = '100'
# print(eval(a+"1+2"))
# # 先执行eval()函数内部先执行字符串的拼接 '100'+"1+2" = '1001+2' 再将字符串'1001+2'通过eval转化得到1001+2 = 1003
# b = '10'
# c = "1+2"
# print(b+c)

# 概念模型（概念数据模型） 是一种面向客观世界、面向用户的模型，它与具体的数据库管理系统和具体的计算机平台无关
# 数据模型包括数据结构、数据完整性约束和数据操作
# 操作系统的基本功能和任务主要有处理管理（进程管理）、存储管理、设备管理、文件管理和用户接口

# 循环队列： front = rear 队列可能是空也可能为满
# 如果front < rear 则队列中的元素个数为rear-front
# 如果front > rear 则队列中的元素个数为 rear-front+m
# eg： Q(1:50)初始状态为front = rear =50，经过一系列政策的操作后，front - 1 = rear.最坏的情况下需要比较的次数为（）
# front>rear，则元素个数为：rear-front+m = front-1-front+50 = 49，最坏的情况下是n-1 所以是49-1=8


# 计算机整数的表示法中：补码可以直接作加减运算
# 计算机底层是没有乘除的，只有加法和减法，一切乘法和除法，都会演变成加法和减法。加法使用原码计算，减法使用反码和补码计算。
# 软件集成测试采用：一次性组装，自底向上增量组装，自顶向下增量组装
