# -*- coding: utf-8 -*-
# 考点1
# 栈的出栈顺序
# 假设栈的入栈顺序是 a,b,c,d,e
# 栈的出栈顺序是 e,d,c,b,a

# 考点2
# 满的二叉树，指的是最下面一层叶子节点的个数是齐全的
#     1
#   1   1
#  1 1 1 1
# 不满的如下，最底层少了节点
#     1
#   1   1
#  1   1
# 性质1
# 二叉树第i层节点数最多为2 的（i-1) 次方个节点
#     1
#   1   1
#  1 1 1 1
# 上面这个就是一个满的二叉树，他的第3层节点数是4，也就是2的（3-1）次方
# 考试的时候可以自己画，层数太多了就用公式算

# 二叉树的深度，指的是二叉树的层数
# 求深度为5的二叉树叶子节点的个数，指的就是，一个只有五层的二叉树，求最下面一层节点的个数，于是可以利用上面的公式

# 二叉树节点的度指的是这个节点下面还有几个子节点，有一个就是度为1
# 叶子节点是最后一层的节点，所以叶子节点的度为0

# 性质 2
# 在任意一棵二叉树中，度为 0 的结点，总是比度为 2 的结点多一个。

# 遍历方式
# 我们知道数组是线性的结构（也就是直线的)，可以顺序循环
# 二叉树的三种循环，前序遍历，中序遍历，后序遍历
# 前序遍历，口决，根左右(先访问根，在访问根的左节点，在访问根的右节点)
#   a
#  b  c
# d e f g
# 前序遍历的结果是a->b->d->e->c->f->g
# 中序遍历，口决，左根右（先访
# 中序遍历的结果是d->b->e->a->f->c->g
# 后序遍历，口决，左右根
# 后序遍历的结果是d->e->b->f->g->c-a


# 考点3 时间复杂度
# 以下出现的log(n) 都表示log2(n)的简写
# 对数组进行完成的循环，时间复杂度为o(n)
# 对数组进行嵌套循环，时间复杂度为o(n^2)
# 常见算法的时间复杂度
# 冒泡排序 o(n^2)
# 快速排序 o(nlog(n))  特点所需内存最高，速度最快
# 归并排序 o(nlog(n))  速度较快
# 堆排序 o(nlog(n))
# 插入排序 o(n^2) 特点希尔排序插入排序的优化
# 希尔排序 o(nlog(n)) 希尔排序对插入排序的优化
# 顺序查找 o(n)  (有序和无序都支持，但是时间复杂度是完整的循环，比如数组[1,2,3...,1000], 要找1000有没有出现过，需要循环到最后一位，所以最坏的时间复杂度是o(n))
# 二分查找 o(log(n)) (只能针对数组是有序的才可以使用)
# 哈希查找 时间复杂的o(1) (字典利用了哈希算法，所以字典的查询速度很快，缺点构建了一个额外的字典的所耗费的内存)


# 快速排序时间复杂度o(logn),最坏的时间复杂度o(n^2)
# 希尔排序属于插入类排序，是对插入排序的优化，最好的时间复杂o(logn), 最坏的时间复杂度是o(n^(1.5))
# 堆排序，属于稳定排序，时间复杂度稳定o(logn)
# 归并排序，属于稳定排序，时间复杂度稳定o(logn)
# 冒泡排序，最好和最坏的时间复杂度为o(n^2)
# 选择排序，最坏的时间复杂度为0(n^2) ，最好的时间复杂度仅仅比冒泡排序快一点

# 考点4 数据库-关系代数

# R ⋃ S 表示R和U的并集,R和U其实是一种数据集（select语句查出来的2个结果取并集)
# R ⋂ S 表示R和U的交集
# R — S 表示R和S的差集 出现在R不出现在S中的元素
# R * S 表示笛卡尔
# 假设我们的表是学号和年龄
# R的sql语句查出来的结果是
# id age
# 1 15
# 2 16
# 3 19
# S的结果
# id age
# 3  19
# 4  20

# R ⋃ S结果如下
# id age
# 1 15
# 2 16
# 3 19
# 4 20

# R ⋂ S结果如下
# id age
# 3 19

# R — S结果如下
# id age
# 1 15
# 2 16

# 数据库实现了专门的运算符实现上述运算
# 选择、投影、连接
